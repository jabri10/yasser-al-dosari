<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Shooter Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: black;
      font-family: Arial, sans-serif;
    }

    canvas {
      display: block;
      margin: 0 auto;
      background-color: #111;
    }

    .game-over {
      color: white;
      font-size: 48px;
      text-align: center;
      margin-top: 200px;
      position: absolute;
      width: 100%;
      font-family: 'Arial', sans-serif;
    }

    .score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 24px;
    }

    #gameCanvas {
      border: 2px solid #fff;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="game-over" id="gameOverText" style="display:none;">Game Over</div>
  <div class="score" id="scoreText">Score: 0</div>

  <script>
    // Set up canvas and context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 600;

    // Game variables
    let player, bullets = [], enemies = [], score = 0, gameOver = false;
    const enemySpeed = 2, bulletSpeed = 4;

    // Player object
    class Player {
      constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height - 50;
        this.width = 50;
        this.height = 50;
        this.speed = 5;
        this.image = new Image();
        this.image.src = 'https://www.iconsdb.com/icons/preview/black/spaceship-xxl.png'; // Spaceship icon
      }
      move() {
        if (keys[37] && this.x > 0) this.x -= this.speed; // Left
        if (keys[39] && this.x < canvas.width - this.width) this.x += this.speed; // Right
      }
      draw() {
        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
      }
    }

    // Bullet object
    class Bullet {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 5;
        this.height = 10;
      }
      move() {
        this.y -= bulletSpeed;
      }
      draw() {
        ctx.fillStyle = 'white';
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    // Enemy object
    class Enemy {
      constructor() {
        this.x = Math.random() * (canvas.width - 50);
        this.y = -50;
        this.width = 50;
        this.height = 50;
      }
      move() {
        this.y += enemySpeed;
      }
      draw() {
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    // Keyboard controls
    const keys = {};
    document.addEventListener('keydown', (e) => { keys[e.keyCode] = true; });
    document.addEventListener('keyup', (e) => { keys[e.keyCode] = false; });

    // Initialize player
    player = new Player();

    // Spawn enemies
    function spawnEnemy() {
      if (!gameOver) {
        const enemy = new Enemy();
        enemies.push(enemy);
      }
    }

    // Collision detection
    function checkCollisions() {
      for (let i = 0; i < bullets.length; i++) {
        for (let j = 0; j < enemies.length; j++) {
          if (bullets[i] && enemies[j]) {
            if (bullets[i].x < enemies[j].x + enemies[j].width &&
              bullets[i].x + bullets[i].width > enemies[j].x &&
              bullets[i].y < enemies[j].y + enemies[j].height &&
              bullets[i].y + bullets[i].height > enemies[j].y) {
              // Bullet hit enemy
              enemies.splice(j, 1);
              bullets.splice(i, 1);
              score += 10;
              updateScore();
              break;
            }
          }
        }
      }

      for (let i = 0; i < enemies.length; i++) {
        if (enemies[i].x < player.x + player.width &&
          enemies[i].x + enemies[i].width > player.x &&
          enemies[i].y < player.y + player.height &&
          enemies[i].y + enemies[i].height > player.y) {
          // Game Over if enemy hits player
          gameOver = true;
          document.getElementById('gameOverText').style.display = 'block';
        }
      }
    }

    // Update score display
    function updateScore() {
      document.getElementById('scoreText').textContent = 'Score: ' + score;
    }

    // Main game loop
    function gameLoop() {
      if (gameOver) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      player.move();
      player.draw();

      // Draw and move bullets
      for (let i = 0; i < bullets.length; i++) {
        bullets[i].move();
        bullets[i].draw();
        if (bullets[i].y < 0) bullets.splice(i, 1);
      }

      // Draw and move enemies
      for (let i = 0; i < enemies.length; i++) {
        enemies[i].move();
        enemies[i].draw();
        if (enemies[i].y > canvas.height) enemies.splice(i, 1);
      }

      checkCollisions();

      // Continue game loop
      if (!gameOver) requestAnimationFrame(gameLoop);
    }

    // Shoot bullet when spacebar is pressed
    document.addEventListener('keydown', (e) => {
      if (e.key === ' ' && !gameOver) {
        const bullet = new Bullet(player.x + player.width / 2 - 2.5, player.y);
        bullets.push(bullet);
      }
    });

    // Start spawning enemies at intervals
    setInterval(spawnEnemy, 1000);

    // Start game loop
    gameLoop();
  </script>
</body>
</html>


